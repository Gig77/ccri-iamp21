include "qc.and"
include "degTable.and"
include "degBoxPlot.and"
include "goClustering.and"
include "expressionHeatmap.and"
include "pgeReport.and"

// --------------- //
//  CONFIGURATION  //
// --------------- //

title = "iAMP21 RNA-seq"
authors = "Christian Frech"
useFunct = false
gtf = INPUT(path="/mnt/synology/data/christian/iamp/data/current/Homo_sapiens.GRCh37.75.etv6runx1.gtf.gz")
ensembl = INPUT(path="/usr/local/share/anduril-bundles/moksiskaan/etc/ensemblHomoSapiens.properties") /** JDBC parameters for Ensembl~\cite{Flicek2008} database. */
go = INPUT(path="/opt/moksiskaan/pipeline/exec/output/goDB-in.obo")  /** Gene Ontology~\cite{Ashburner2000} */
enrichmentTable = INPUT(path="/opt/moksiskaan/pipeline/exec/output/GOEnrichment_9606.csv") // Moksiskaan specific a priori probabilities for the Gene ontology terms.
fcLimitInclude  = 1.00
pLimitInclude   = 1e-8
qLimitInclude   = 1e-4
minExprInclude  = 100.00
fcLimitExclude  = 1.00
qLimitExclude   = 0.20
pLimitExclude   = 0.1
minExprExclude  = 100.00
maxNA    = 0.90

inputBamDir = INPUT(path="/mnt/synology/data/christian/iamp/data/current/bam", recursive=false)
inputBamFiles = Folder2Array(folder1 = inputBamDir, filePattern = "C57C3ACXX_CV_([^_]+)_.*[.]bam$")

moksiskaanInit = MoksiskaanInit(showLog='EnsemblImport,PathwayCommonsImport,PINAImport,WikiPathways')

rConfig = RConfigurationReport(packages = "base,csbl.go,DESeq2,igraph", sectionType = "subsection")
bibtexMoksiskaan = INPUT(path="/usr/local/share/anduril-bundles/moksiskaan/components/report-BibTeX/moksiskaan.bib")
bibtexSequencing = INPUT(path="/usr/local/share/anduril-bundles/sequencing/components/report-BibTeX/sequencing.bib")
docTemplate = LatexTemplate(authors  = std.quote(authors, type="LaTeX"),
                            bibtex1  = rConfig.citations,
                            bibtex2  = bibtexMoksiskaan,
                            bibtex3  = bibtexSequencing,
                            title    = std.quote(title, type="LaTeX"),
                            printTOC = true)


//--- SAMPLE SETUP ------------------------------------------------------------------//

annotation = INPUT(path="/mnt/synology/data/christian/iamp/results/current/qlucore/annotations.txt")
sampleGroups = TableQuery(table1 = annotation @require,
                          query  = """\
	SELECT * FROM (
	  SELECT "Subtype"                                     AS "ID",
		GROUP_CONCAT("Name" ORDER BY "Name" SEPARATOR ',') AS "Members",
		'median'                                           AS "Type",
		"Subtype"                                          AS "Description"
		FROM   table1
		GROUP  BY "Subtype"
      UNION
	  SELECT 'immature'                                     AS "ID",
		GROUP_CONCAT("Name" ORDER BY "Name" SEPARATOR ',') AS "Members",
		'median'                                           AS "Type",
		'Immature B-cells'          AS "Description"
		FROM   table1
		WHERE "Name" = 'S1'
      UNION
	  SELECT 'preB'                                     AS "ID",
		GROUP_CONCAT("Name" ORDER BY "Name" SEPARATOR ',') AS "Members",
		'median'                                           AS "Type",
		'preB-cells'          AS "Description"
		FROM   table1
		WHERE "Name" = 'S2'
	  UNION
	  SELECT 'mature'                                     AS "ID",
		GROUP_CONCAT("Name" ORDER BY "Name" SEPARATOR ',') AS "Members",
		'median'                                           AS "Type",
		'mature B-cells'          AS "Description"
		FROM   table1
		WHERE "Name" = 'S3'
      UNION
	  SELECT 'non-iAMP'                                     AS "ID",
		GROUP_CONCAT("Name" ORDER BY "Name" SEPARATOR ',') AS "Members",
		'median'                                           AS "Type",
		'Non-iAMP21 samples'          AS "Description"
		FROM   table1
		WHERE "Subtype" <> 'iAMP'
      UNION
	  SELECT 'non-PC'                                     AS "ID",
		GROUP_CONCAT("Name" ORDER BY "Name" SEPARATOR ',') AS "Members",
		'median'                                           AS "Type",
		'Non-P2RY8-CRLF2 samples'          AS "Description"
		FROM   table1
		WHERE "Subtype" <> 'PC'
      UNION
	  SELECT 'non-ER'                                     AS "ID",
		GROUP_CONCAT("Name" ORDER BY "Name" SEPARATOR ',') AS "Members",
		'median'                                           AS "Type",
		'Non-ETV6-RUNX1 samples'          AS "Description"
		FROM   table1
		WHERE "Subtype" <> 'ER'
	)	
	ORDER BY "ID"
                                   """)
sampleGroupsSimple = CSVFilter(csv=sampleGroups, regexp="ID=iAMP|PC|ER|CD19")

//--- COMPARISONS SETUP ------------------------------------------------------------------//

comparisons = INPUT(path="/mnt/synology/data/christian/iamp/results/current/anduril/comparisons.tsv")

/*
comparisons = SampleGroupCreator(data1        = sampleGroups,
                              pattern1     = "iAMP,PC",
                              pattern2     = "iAMP,ER",
                              pattern3     = "ER,PC",
                              pattern4     = "(iAMP|PC|ER),immature",
//                              pattern5     = "(iAMP|PC|ER),CD19",
                              definition1  = "fciAMPvsPC,ratio,iAMP21 vs. P2RY8-CRLF2",
                              definition2  = "fciAMPvsER,ratio,iAMP21 vs. ETV6-RUNX1",
                              definition3  = "fcERvsPC,ratio,ETV6-RUNX1 vs. P2RY8-CRLF2",
                              definition4  = "fc$1vsimmature,ratio,$1 vs. immature",
//                              definition5  = "fc$1specvsCD19,ratio,$1-specific expression",
                              patternTypes = "relist,relist,relist,relist",
                              columns      = "ID")
*/


//--- ALIGNMENT ---------------------------------------------------------//

alignedBAMs = GSNAPAlignBams
(
	inputBAMs = inputBamFiles, 
    options   = "--nthreads 18 --maxsearch=100 --npaths=1 --max-mismatches=1 --novelsplicing=0 --batch=4 --genome-unk-mismatch=0",
    docker    = "cfrech/anduril-gsnap"
)

//--- EXPRESSION MATRIX -------------------------------------------------//

bamCounts = HTSeq(alignments = alignedBAMs, annotationGTF = gtf, options = "-t exon -s no")
deseqExprMatrix = DESeqExpr
(
	geneCounts  = bamCounts,
    counts      = false,
    maxNA       = maxNA,
    normalized  = true
)

//--- QUALITY CONTROL ---------------------------------------------------//

qcReport  = getQCReport
(
	alignedBAMs = alignedBAMs.array,
    gtf = gtf,
    force expr   = deseqExprMatrix.expr,
    force groups = sampleGroupsSimple
)

//--- DIFFERENTIAL GENE EXPRESSION ANALYSIS -----------------------------------------------------//

// mysql --host=ensembldb.ensembl.org --port=5306 --database=homo_sapiens_core_73_37 --user=anonymous -B -A -e "select stable_id as ensembl,description from gene where description is not null;" > /mnt/biowaste/data2/christian.frech/iamp/results/current/anduril/ensembl.homo_sapiens_73_37.geneAnnotations.tsv
geneAnnot = INPUT(path="/mnt/synology/data/christian/iamp/results/current/anduril/ensembl.homo_sapiens_75_37.geneAnnotations.tsv")

gMoksisA = PiispanhiippaAnnotator(sourceKeys = deseqExprMatrix.expr @require,
                                  connection = moksiskaanInit.connection,
                                  inputDB    = XrefType_Ensembl_gene,
                                  organism   = Organism_Homo_sapiens,
                                  targetDB   = "BioentityName,DNARegion")

geneNames = CSVCleaner(original   = gMoksisA.bioAnnotation,
                       columns    = "sourceKey,BioentityName,DNARegion",
                       rename     = "sourceKey=Ensembl,BioentityName=Gene",
                       skipQuotes = "*",
                       trim       = true,
                       @keep      = true)



//gstats  = record(genes=geneNames)
gstats  = record()
groups  = record()
degLst  = record()
pgeReports = record()
eCSSRow = ""
for comparison : std.itercsv(comparisons) {
  gCase    = null
  gControl = null
  for g : std.split(comparison.Members, ',') {
     if (gCase    == null) { gCase    = g } else
     if (gControl == null) { gControl = g } else
     std.fail("Too many groups listed for ", comparison.ID, " (", comparison.Description, "). Members = ", comparison.Members, sep='')
  }
  setName = "stest_"+comparison.ID
  std.echo("***** Comparing", gCase, "expressions against", gControl, "expressions: "+setName)
  gLab = std.strReplace(comparison.ID, "^fc", "")
  groups[gLab] = {
    'id'       = gLab,
    'caseG'    = gCase,
    'controlG' = gControl,
    'stest'    = setName,
    'desc'     = comparison.Description
  }
  eCSSRow = "*\t"+comparison.ID+"\t0.00\ttrue\tNA\tNA\tNA\t#0000BB\t#ffffff\tNA\t<= -"+fcLimitInclude+"\n"+
            "*\t"+comparison.ID+"\t0.00\ttrue\tNA\tNA\tNA\t#00FF00\t#ffffff\tNA\t>= "+ fcLimitInclude+"\n"+
            "*\tp"+gLab+"\t0.00e00\tNA\tNA\tNA\tNA\tNA\tNA\tNA\tNA\n"+
            "*\tq"+gLab+"\t0.00e00\tNA\tNA\tNA\tNA\tNA\tNA\tNA\tNA\n"+
            "*\tp"+gLab+"\tNA\ttrue\tNA\tNA\tNA\t#ff0000\tNA\tNA\t<= "+pLimitInclude+"\n"+
            "*\tq"+gLab+"\tNA\ttrue\tNA\tNA\tNA\t#ff0000\tNA\tNA\t<= "+qLimitInclude+"\n"+
            eCSSRow

  if (gLab == "iAMPspecvsCD19") {
	  @out.table.filename = "stats.csv"
	  stest = TableQuery(table1 = stest_fciAMPvsCD19.table @require,
	                     table2 = degs_iAMPvsPC.table @ require,
	                     table3 = degs_iAMPvsER.table @ require,
	                     table4 = stest_fcERvsPC.table @ require,
	                       query  = """\
	                                SELECT A."ids",	
	                                       A."meanExpriAMPvsCD19" AS "meanExpriAMPspecvsCD19", 
	                                       A."fciAMPvsCD19"       AS "fciAMPspecvsCD19",
	                                       A."fcSEiAMPvsCD19"     AS "fcSEiAMPspecvsCD19", 
	                                       A."stat",
	                                       A."piAMPvsCD19"        AS "piAMPspecvsCD19",
	                                       A."qiAMPvsCD19"        AS "qiAMPspecvsCD19"
	                                FROM   table1 A 
	                                       INNER JOIN table2 B ON (A."ids" = B."ids")
	                                       INNER JOIN table3 C ON (A."ids" = C."ids")
	                                       LEFT OUTER JOIN table4 D ON (A."ids" = D."ids")
	                                WHERE  (D."fcERvsPC" IS NULL OR ABS(D."fcERvsPC") < """+fcLimitExclude+""" OR  
	                                       D."pERvsPC" IS NULL OR D."pERvsPC" > """+pLimitExclude+""" OR  
	                                       D."qERvsPC" IS NULL OR D."qERvsPC" > """+qLimitExclude+""" OR  
	                                       D."meanExprERvsPC" IS NULL OR D."meanExprERvsPC" < """+minExprExclude+""")
	                                ORDER  BY 1
	                                """,
	                       @name = setName)
	  gstats[gLab] = stest.table
  } else if (gLab == "PCspecvsCD19") {
	  @out.table.filename = "stats.csv"
	  stest = TableQuery(table1 = stest_fcPCvsCD19.table @require,
	                     table2 = degs_iAMPvsPC.table @ require,
	                     table3 = degs_ERvsPC.table @ require,
	                     table4 = stest_fciAMPvsER.table @ require,
	                       query  = """\
	                                SELECT A."ids",	
	                                       A."meanExprPCvsCD19" AS "meanExprPCspecvsCD19", 
	                                       A."fcPCvsCD19"       AS "fcPCspecvsCD19",
	                                       A."fcSEPCvsCD19"     AS "fcSEPCspecvsCD19", 
	                                       A."stat",
	                                       A."pPCvsCD19"        AS "pPCspecvsCD19",
	                                       A."qPCvsCD19"        AS "qPCspecvsCD19"
	                                FROM   table1 A 
	                                       INNER JOIN table2 B ON (A."ids" = B."ids")
	                                       INNER JOIN table3 C ON (A."ids" = C."ids")
	                                       LEFT OUTER JOIN table4 D ON (A."ids" = D."ids")
	                                WHERE  (D."fciAMPvsER" IS NULL OR ABS(D."fciAMPvsER") < """+fcLimitExclude+""" OR  
	                                       D."piAMPvsER" IS NULL OR D."piAMPvsER" > """+pLimitExclude+""" OR  
	                                       D."qiAMPvsER" IS NULL OR D."qiAMPvsER" > """+qLimitExclude+""" OR  
	                                       D."meanExpriAMPvsER" IS NULL OR D."meanExpriAMPvsER" < """+minExprExclude+""")
	                                ORDER  BY 1
	                                """,
	                       @name = setName)
	  gstats[gLab] = stest.table
  } else if (gLab == "ERspecvsCD19") {
	  @out.table.filename = "stats.csv"
	  stest = TableQuery(table1 = stest_fcERvsCD19.table @require,
	                     table2 = degs_iAMPvsER.table @ require,
	                     table3 = degs_ERvsPC.table @ require,
	                     table4 = stest_fciAMPvsPC.table @ require,
	                       query  = """\
	                                SELECT A."ids",	
	                                       A."meanExprERvsCD19" AS "meanExprERspecvsCD19", 
	                                       A."fcERvsCD19"       AS "fcERspecvsCD19",
	                                       A."fcSEERvsCD19"     AS "fcSEERspecvsCD19", 
	                                       A."stat",
	                                       A."pERvsCD19"        AS "pERspecvsCD19",
	                                       A."qERvsCD19"        AS "qERspecvsCD19"
	                                FROM   table1 A 
	                                       INNER JOIN table2 B ON (A."ids" = B."ids")
	                                       INNER JOIN table3 C ON (A."ids" = C."ids")
	                                       LEFT OUTER JOIN table4 D ON (A."ids" = D."ids")
	                                WHERE  (D."fciAMPvsPC" IS NULL OR ABS(D."fciAMPvsPC") < """+fcLimitExclude+""" OR  
	                                       D."piAMPvsPC" IS NULL OR D."piAMPvsPC" > """+pLimitExclude+""" OR  
	                                       D."qiAMPvsPC" IS NULL OR D."qiAMPvsPC" > """+qLimitExclude+""" OR  
	                                       D."meanExpriAMPvsPC" IS NULL OR D."meanExpriAMPvsPC" < """+minExprExclude+""")
	                                ORDER  BY 1
	                                """,
	                       @name = setName)
	  gstats[gLab] = stest.table
  } else if (gLab == "iAMPandPCspecvsCD19") {
	  @out.table.filename = "stats.csv"
	  stest = TableQuery(table1 = stest_fciAMPandPCvsCD19.table @require,
	                     table2 = degs_iAMPvsER.table @ require,
	                     table3 = degs_ERvsPC.table @ require,
	                     table4 = stest_fcERvsCD19.table @ require,
	                       query  = """\
	                                SELECT A."ids",	
	                                       A."meanExpriAMPandPCvsCD19" AS "meanExpriAMPandPCspecvsCD19", 
	                                       A."fciAMPandPCvsCD19"       AS "fciAMPandPCspecvsCD19",
	                                       A."fcSEiAMPandPCvsCD19"     AS "fcSEiAMPandPCspecvsCD19", 
	                                       A."stat",
	                                       A."piAMPandPCvsCD19"        AS "piAMPandPCspecvsCD19",
	                                       A."qiAMPandPCvsCD19"        AS "qiAMPandPCspecvsCD19"
	                                FROM   table1 A 
	                                       INNER JOIN table2 B ON (A."ids" = B."ids")
	                                       INNER JOIN table3 C ON (A."ids" = C."ids")
	                                       LEFT OUTER JOIN table4 D ON (A."ids" = D."ids")
	                                WHERE  (D."fcERvsCD19" IS NULL OR ABS(D."fcERvsCD19") < """+fcLimitExclude+""" OR  
	                                       D."pERvsCD19" IS NULL OR D."pERvsCD19" > """+pLimitExclude+""" OR  
	                                       D."qERvsCD19" IS NULL OR D."qERvsCD19" > """+qLimitExclude+""" OR  
	                                       D."meanExprERvsCD19" IS NULL OR D."meanExprERvsCD19" < """+minExprExclude+""")
	                                ORDER  BY 1
	                                """,
	                       @name = setName)
	  gstats[gLab] = stest.table
  } else {
	  @out.results.filename = "stats.csv"
	  stest = DESeq2
	  (
	  	countFiles = bamCounts,
	    samples = sampleGroups,
	    nameControl = gControl,
	    nameCase = gCase,
	    label = gLab,
	    @name = setName
	  )
	  gstats[gLab] = stest.results
  }

  degCall = TableQuery(table1 = gstats[gLab] @require,
                       query  = """\
                                SELECT DISTINCT "ids", "fc"""+gLab+"""" AS "fc", "p"""+gLab+"""" AS "p", "q"""+gLab+"""" AS "q" 
                                FROM   table1
                                WHERE  (ABS("fc"""+gLab+'''")  >= '''+fcLimitInclude+""") AND
                                       ("p"""+gLab+'''"        <= '''+pLimitInclude +""") AND
                                       ("q"""+gLab+'''"        <= '''+qLimitInclude +""") AND
                                       (("meanExprE"""+gLab+'''" >= '''+minExprInclude+""") OR
                                       ("meanExprC"""+gLab+'''" >= '''+minExprInclude+"""))
                                ORDER  BY 1
                                """,
                       @name  = "degs_"+gLab)
  degLst[gLab] = degCall.table

	//--- POSITIONAL GENE ENRICHMENT -------------------------------------------------------------------------------//
	
	pgeReports[gLab] = PGEReport
	(
		query=degCall.table, 
		reference=gtf, 
		title=gLab,
		pvalue=0.001,
		includeHeader=std.length(pgeReports)==0,
		@name="pge_"+gLab
  )
  
  // make 'CD19+' match in following regular expression 
  gControlEscaped = std.strReplace(gControl,"\\+","\\\\+")
    
  samples = CSV2IDList(table1    = sampleGroups @require,
                       columnIn  = "Members",
                       columnOut = ".GeneId",
                       isList    = true,
                       regexp1   = "ID=("+gCase+"|"+gControlEscaped+")",
                       @name     = "samples_"+gLab)
  groups[gLab].samples = samples.ids
}

 

degReportRefs = XrefLinkRule
(
	moksiskaan = moksiskaanInit.connection,
	columns    = "Ensembl=Ensembl",
	xrefTypes  = XrefType_Ensembl_gene
)

/*
statsAllTable = CSVJoin(array = gstats @require, intersection = true)

statsAllCSS = StringInput(content=std.concat(sep="\n",
  "Row\tColumn\tFormat\tBold\tAlign\tFontSize\tUnderline\tTextColor\tBGColor\tBorder\tCondition",
  "1\t*\tNA\ttrue\tNA\t12\ttrue\t#000000\t#ffffff\tNA\tNA",
  "*\tEnsembl\tNA\tfalse\tleft\t6\tfalse\tNA\tNA\tNA\tNA",
  "*\tDNARegion\tNA\tNA\tleft\t6\tfalse\tNA\tNA\tNA\tNA",
  eCSSRow
))

statsAllExcel = CSV2Excel(csv           = statsAllTable,
                          refs          = degReportRefs,
                          style         = statsAllCSS,
                          frozenColumns = 2,
                          frozenRows    = 1,
                          sheetNames    = "statistics")
*/

//--- VENN DIAGRAMS -------------------------------------------------------------------------------//

degSets = CSV2SetList(tables=degLst)

venn = VennDiagram
(
	sets         = degSets,
	cexSetName   = 0.3,
	cexSetSize   = 0.3,
	doWeights    = true,
	sets1        = "iAMPvsPC,iAMPvsER,ERvsPC",
	sets2        = "iAMPvsImmature,PCvsImmature,ERvsImmature",
	sets3        = "iAMPvsPreB,PCvsPreB,ERvsPreB",
	sets4        = "iAMPvsMature,PCvsMature,ERvsMature",
	sectionTitle = "Gene set comparisons",
	sectionType  = "subsection",
	types        = "circles"
)

degReports = record(venn=venn.report)

//--- DEG REPORTS ------------------------------------------------------------------------------------------------------------//

degTables = record()
for ID, group : groups 
{
	std.echo("***** Preparing results for", ID, "comparison.")
	
	degs  = degLst[ID]
	stest = gstats[ID]

	//--- PREPARE TABLE WITH DIFFERENTIALLY EXPRESSED GENES ------------------------------------------------------------------//

	degTable = TableQuery
	(
		table1 = degs      @require,
		table2 = stest     @require,
		table3 = geneNames @require,
		table4 = geneAnnot @require,
		query  = '''
			SELECT G."ids"                      AS "Ensembl",
			A."Gene"                     AS "Gene",
			S."fc'''+group.id+'''"       AS "fc",
			S."meanExprE'''+group.id+'''" AS "exprA",
			S."meanExprC'''+group.id+'''" AS "exprB",
			S."q'''+group.id+'''"        AS "qValue",
			CONCAT(D."Chromosome Name", D."Band") AS "Band",
			SUBSTR(D."Description", 1, 65) AS "Description",
			CASEWHEN(S."fc'''+group.id+'''" > 0, 1, -1) AS "status"
			FROM   table1 G, table2 S
				LEFT OUTER JOIN table3 AS A ON (G."ids" = A."Ensembl")
				LEFT OUTER JOIN table4 AS D ON (G."ids" = D."Ensembl Gene ID")
			WHERE  (G."ids" = S."ids")
			ORDER  BY "qValue", ABS("fc") DESC
		''',
		@name  = "degTable_"+ID
	)

	degTables[ID] = degTable  // we write them to an Excel file later

	//--- TABLES WITH UP- AND DOWN-REULATED GENES --------------------------------------------------------------------------//

	degTableUp = getDEGTableReport
	(
		degs = degTable,
		degReportRefs = degReportRefs,
		direction = "up",
		group = group,
		ID=ID,
		@name = "degTableUp_"+ID
	)

	degTableDn = getDEGTableReport
	(
		degs = degTable,
		degReportRefs = degReportRefs,
		direction = "down",
		group = group,
		ID=ID,
		@name = "degTableDn_"+ID
	)

	//--- BOX PLOTS TOP UP- AND DOWN-REGULATED GENES ----------------------------------------------------------------------//

	degBoxplotUp = getDEGBoxPlots
	(
		degs = degTable,
		exprMatrix = deseqExprMatrix.expr,
		sampleGroupsSimple=sampleGroupsSimple,
		geneAnnot=geneAnnot,
		direction="up",
		group=group,
		@name = "degBoxplotUp_"+ID
	)

	degBoxplotDn = getDEGBoxPlots
	(
		degs = degTable,
		exprMatrix = deseqExprMatrix.expr,
		sampleGroupsSimple=sampleGroupsSimple,
		geneAnnot=geneAnnot,
		direction="down",
		group=group,
		@name = "degBoxplotDn_"+ID
	)

	//--- EXPRESSION HEATMAP --------------------------------------------------------------------------//

	exprMatrixFiltered = CSVFilter
	(
		csv            = deseqExprMatrix.expr,
		auxiliary      = degs @require,
		includeColumns = group.samples,
		includeColumns = "RowName",
		colOrder       = true,
		@name          = "exprMatrix_"+ID
	)                      

	exprHeatmap = getHeatmapReport
	(
		exprMatrix = exprMatrixFiltered,
		geneNames = geneNames,
		group = group,
		@name = "heatmap"+ID
	)

	//--- GO CLUSTERING -------------------------------------------------------------------------------//

	goClustering = getGOClusteringReport
	(
		exprMatrix = exprMatrixFiltered,
		geneNames = geneNames,
		ID = ID,
		@name = "goClustering"+ID
	)
  
	//--- COMBINE REPORTS -----------------------------------------------------------------------------//

	degReports[ID] = LatexCombiner
	(
		latex1=degTableUp, 
		latex2=degBoxplotUp, 
		latex3=degTableDn, 
		latex4=degBoxplotDn, 
		latex5=exprHeatmap, 
		latex6=goClustering, 
		sectionTitle="DEGs: "+group.desc, 
		sectionType="section"
	)
}

// add report about expression of selected genes
boxplotSelectedGenes = REvaluate(var1   = deseqExprMatrix.expr    @require @doc="Expression matrix",
                        table1 = sampleGroupsSimple  @require @doc="Sample sets",
                        table2 = geneAnnot           @require @doc="Gene annotations",
                        param1 = 'Expression of manually selected genes. MME=CD10; MS4A1=CD20',
                        param2 = "ETV6,RUNX1,CRLF2,P2RY8,EBF1,PAX5,VPREB1,HMGN1,MME,CD34,CD19,MS4A1",
                        script = boxplotscript)
degReports["selectedGenes"] = LatexCombiner(latex1=boxplotSelectedGenes.document, pagebreak=true, sectionTitle="Expression of selected genes", sectionType="section")

degReports["pges"] = LatexCombiner
(
	array=pgeReports, 
	pagebreak=true, 
	sectionTitle="Positional gene enrichment (PGE) of differentially expressed genes", 
	sectionType="section"
)

degViews = LatexCombiner(array        = degReports,
                         pagebreak    = true,
                         tail         = '\newpage{}',
                         sectionTitle = "Differentially expressed genes")

degTablesExcel = CSV2Excel(array         = degTables,
                           refs          = degReportRefs,
                           frozenColumns = 2,
                           frozenRows    = 1,
                           missingValue  = '')

// -------------------- //
//  FUNCTIONAL ANALYSIS //
// -------------------- //

include "functionalAnalysis.and"
if (useFunct) {
	createFunctionalAnalysisReport(groups=groups, degTables=degTables, gstats=gstats, degLst=degLst)
}

// --------------------------------
// Experimental setup
// --------------------------------
expSetup1   = ExperimentSetup(force groups = sampleGroups,
                              definWidth   = 10.0,
                              descWidth    = 6.0,
                              sectionType  = "subsection",
                              sectionTitle = "Sample groups")
expSetup2   = ExperimentSetup(force groups = comparisons,
                              definWidth   = 7.0,
                              descWidth    = 9.0,
                              sectionType  = "subsection",
                              sectionTitle = "Comparisons between sample groups")
expSetupGV1 = GraphVisualizer(expSetup1.graph,
                              reportHeight = 26,
                              reportWidth  = 18,
                              layout       = "spring2",
                              latexTail    = '\newpage{}')
expSetupGV2 = GraphVisualizer(expSetup2.graph,
                              reportHeight = 26,
                              reportWidth  = 18,
                              layout       = "spring2",
                              latexTail    = '\newpage{}')

expReport = LatexCombiner(expSetup1.report,
  						  expSetup2.report,
  						  expSetupGV1.figure,
  						  expSetupGV2.figure,
                          sectionTitle = "Experimental setup",
                          sectionType  = "section",
                          pagebreak    = true)


// --------------------------------
// final report
// --------------------------------


combinedLatex = LatexCombiner(array={
  expReport,
  qcReport,
  degViews,
  rConfig.report},
  @keep = false,
  @cpu=4,
  @memory=1000,
  @host="biowaste"
)

combinedPDF = LatexPDF(document = combinedLatex,
                    header   = docTemplate.header,
                    footer   = docTemplate.footer,
                    useRefs  = true,
                    verbose  = false)

OUTPUT(combinedPDF.document)
