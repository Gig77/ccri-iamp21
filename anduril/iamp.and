// --------------- //
//  CONFIGURATION  //
// --------------- //

title = "iAMP21 RNA-seq"
authors = "Christian Frech"
useFunct = false
gtf = INPUT(path="/mnt/synology/data/christian/iamp/data/current/Homo_sapiens.GRCh37.75.etv6runx1.gtf.gz")
ensembl = INPUT(path="/usr/local/share/anduril-bundles/moksiskaan/etc/ensemblHomoSapiens.properties") /** JDBC parameters for Ensembl~\cite{Flicek2008} database. */
geneAnnot = INPUT(path="/mnt/synology/data/christian/iamp/results/current/anduril/ensembl.homo_sapiens_75_37.geneAnnotations.tsv")
geneGO = INPUT(path="/opt/moksiskaan/pipeline/exec/output/geneGO_9606.csv")  /** Gene Ontology annotations of all genes */
go = INPUT(path="/opt/moksiskaan/pipeline/exec/output/goDB-in.obo")  /** Gene Ontology~\cite{Ashburner2000} */
similarityTable = INPUT(path="/opt/moksiskaan/pipeline/exec/output/GOSimilarity_9606.csv") // Moksiskaan specific similarities for the Gene ontology terms
enrichmentTable = INPUT(path="/opt/moksiskaan/pipeline/exec/output/GOEnrichment_9606.csv") // Moksiskaan specific a priori probabilities for the Gene ontology terms.
fcLimitInclude  = 1.00
pLimitInclude   = 1e-8
qLimitInclude   = 1e-4
minExprInclude  = 100.00
fcLimitExclude  = 1.00
qLimitExclude   = 0.20
pLimitExclude   = 0.1
minExprExclude  = 100.00
maxNA    = 0.90
dockerPrefix = "docker run --rm=true -e ANDURIL_HOME=/usr/local/share/anduril -e ANDURIL_BUNDLES=/usr/local/share/anduril-bundles -e ANDURIL_USER_ID=10001 -e ANDURIL_GROUP_ID=10000 --volumes-from anduril-moksiskaan "

inputBamDir = INPUT(path="/mnt/synology/data/christian/iamp/data/current/bam", recursive=false)
inputBamFiles = Folder2Array(folder1 = inputBamDir, filePattern = "C57C3ACXX_CV_([^_]+)_.*[.]bam$")

moksiskaanInit = MoksiskaanInit(showLog='EnsemblImport,PathwayCommonsImport,PINAImport,WikiPathways')

rConfig = RConfigurationReport(packages = "base,csbl.go,DESeq2,igraph", sectionType = "subsection")
bibtexMoksiskaan = INPUT(path="/usr/local/share/anduril-bundles/moksiskaan/components/report-BibTeX/moksiskaan.bib")
bibtexSequencing = INPUT(path="/usr/local/share/anduril-bundles/sequencing/components/report-BibTeX/sequencing.bib")
docTemplate = LatexTemplate(authors  = std.quote(authors, type="LaTeX"),
                            bibtex1  = rConfig.citations,
                            bibtex2  = bibtexMoksiskaan,
                            bibtex3  = bibtexSequencing,
                            title    = std.quote(title, type="LaTeX"),
                            printTOC = true)


// -------------------------------- //
//  SAMPLES, GROUPS and COMPARISONS //
// -------------------------------- //

annotation = INPUT(path="/mnt/synology/data/christian/iamp/results/current/qlucore/annotations.txt")
sampleGroups = TableQuery(table1 = annotation @require,
                          query  = """\
	SELECT * FROM (
	  SELECT "Subtype"                                     AS "ID",
		GROUP_CONCAT("Name" ORDER BY "Name" SEPARATOR ',') AS "Members",
		'median'                                           AS "Type",
		"Subtype"                                          AS "Description"
		FROM   table1
		GROUP  BY "Subtype"
      UNION
	  SELECT 'immature'                                     AS "ID",
		GROUP_CONCAT("Name" ORDER BY "Name" SEPARATOR ',') AS "Members",
		'median'                                           AS "Type",
		'Immature B-cells'          AS "Description"
		FROM   table1
		WHERE "Name" = 'S1'
      UNION
	  SELECT 'preB'                                     AS "ID",
		GROUP_CONCAT("Name" ORDER BY "Name" SEPARATOR ',') AS "Members",
		'median'                                           AS "Type",
		'preB-cells'          AS "Description"
		FROM   table1
		WHERE "Name" = 'S2'
	  UNION
	  SELECT 'mature'                                     AS "ID",
		GROUP_CONCAT("Name" ORDER BY "Name" SEPARATOR ',') AS "Members",
		'median'                                           AS "Type",
		'mature B-cells'          AS "Description"
		FROM   table1
		WHERE "Name" = 'S3'
      UNION
	  SELECT 'non-iAMP'                                     AS "ID",
		GROUP_CONCAT("Name" ORDER BY "Name" SEPARATOR ',') AS "Members",
		'median'                                           AS "Type",
		'Non-iAMP21 samples'          AS "Description"
		FROM   table1
		WHERE "Subtype" <> 'iAMP'
      UNION
	  SELECT 'non-PC'                                     AS "ID",
		GROUP_CONCAT("Name" ORDER BY "Name" SEPARATOR ',') AS "Members",
		'median'                                           AS "Type",
		'Non-P2RY8-CRLF2 samples'          AS "Description"
		FROM   table1
		WHERE "Subtype" <> 'PC'
      UNION
	  SELECT 'non-ER'                                     AS "ID",
		GROUP_CONCAT("Name" ORDER BY "Name" SEPARATOR ',') AS "Members",
		'median'                                           AS "Type",
		'Non-ETV6-RUNX1 samples'          AS "Description"
		FROM   table1
		WHERE "Subtype" <> 'ER'
	)	
	ORDER BY "ID"
                                   """)
sampleGroupsSimple = CSVFilter(csv=sampleGroups, regexp="ID=iAMP|PC|ER|CD19")

comparisons = INPUT(path="/mnt/synology/data/christian/iamp/results/current/anduril/comparisons.tsv")

/*
comparisons = SampleGroupCreator(data1        = sampleGroups,
                              pattern1     = "iAMP,PC",
                              pattern2     = "iAMP,ER",
                              pattern3     = "ER,PC",
                              pattern4     = "(iAMP|PC|ER),immature",
//                              pattern5     = "(iAMP|PC|ER),CD19",
                              definition1  = "fciAMPvsPC,ratio,iAMP21 vs. P2RY8-CRLF2",
                              definition2  = "fciAMPvsER,ratio,iAMP21 vs. ETV6-RUNX1",
                              definition3  = "fcERvsPC,ratio,ETV6-RUNX1 vs. P2RY8-CRLF2",
                              definition4  = "fc$1vsimmature,ratio,$1 vs. immature",
//                              definition5  = "fc$1specvsCD19,ratio,$1-specific expression",
                              patternTypes = "relist,relist,relist,relist",
                              columns      = "ID")
*/


//--- ALIGNMENT ---------------------------------------------------------//

alignedBAMs = GSNAPAlignBams
(
	inputBAMs=inputBamFiles, 
    cmdPrefix=dockerPrefix+"cfrech/anduril-gsnap /home/anduril/init.sh",
    options="--nthreads 18 --maxsearch=100 --npaths=1 --max-mismatches=1 --novelsplicing=0 --batch=4 --genome-unk-mismatch=0"
)

//--- EXPRESSION MATRIX -------------------------------------------------//

//bamCounts = HTSeqBam2Counts(alignments    = alignedBAMs,
//			    annotationGTF = gtf,
//                            dexseq_dir    = "/opt/DEXSeq/python_scripts/",
//                            entity        = "Gene",
//                            format        = "bam",
//                            sorted        = true)

bamCounts = HTSeq(alignments = alignedBAMs, annotationGTF = gtf, options = "-t exon -s no")

deseqExprMatrix = DESeqExpr
(
	geneCounts  = bamCounts,
    counts      = false,
    maxNA       = maxNA,
    normalized  = true
)

//--- QUALITY CONTROL ---------------------------------------------------//

include "qc.and"
qcReport  = getQCReport
(
	alignedBAMs = alignedBAMs.array,
    gtf = gtf,
    force expr   = deseqExprMatrix.expr,
    force groups = sampleGroupsSimple
)

/*
deseqNorm = REvaluate(var1 = bamCounts @require @doc="Matrix with raw read counts",
                      script = StringInput(content="""
									samples <- read.delim(paste0(var1, "/_index"))
									names(samples) <- c("sampleName", "fileName")
									library(DESeq2)
									dds  <- DESeqDataSetFromHTSeqCount(sampleTable = samples, directory="/", design=~1)
									rld <- rlog(dds)
						  			table.out <- assay(rld)
						       """)
					  )

exprQCNorm  = ExprQC(force expr   = deseqNorm.table,
                     force groups = sampleGroupsSimple,
                     title        = "Normalized (rlog) DESeq2 signal")
*/


//--- DIFFERENTIAL GENE EXPRESSION ANALYSIS -----------------------------------------------------//

// fetch Ensembl gene description for later use in output lists
// NOTE: this is INCREDIBLY slow (takes hours...); did this instead:
// mysql --host=ensembldb.ensembl.org --port=5306 --database=homo_sapiens_core_73_37 --user=anonymous -B -A -e "select stable_id as ensembl,description from gene where description is not null;" > /mnt/biowaste/data2/christian.frech/iamp/results/current/anduril/ensembl.homo_sapiens_73_37.geneAnnotations.tsv
// geneAnnot = KorvasieniAnnotator(sourceKeys = geneNames,
//                                 connection  = ensembl,
//                                 inputType   = "Gene",
//                                 inputDB     = ".GeneId",
//                                 targetDB    = ".GeneDesc",
//                                 keyColumn   = "Ensembl",
//                                 rename      = ".GeneDesc=description",
//                                 skipLevel   = "source",
//                                 indicator   = false,
//                                 unique      = true)

stestR = StringInput(content="""\
	myArray     <- Array.read(cf,"var1")
	sNames      <- myArray$Key
	g1N         <- unlist(strsplit(table1[table1[,'ID']==param1,'Members'],','))
	g2N         <- unlist(strsplit(table1[table1[,'ID']==param2,'Members'],','))
	condition   <- rep(NA, length(sNames))
	condition[match(g1N,sNames)] <- param1
	condition[match(g2N,sNames)] <- param2
	condition   <- factor(x=condition, levels=c(param1,param2), ordered=FALSE)
	sampleTable <- data.frame(sampleName = sNames,
	                           fileName   = myArray$File,
	                           condition  = condition)
	sampleTable <- sampleTable[!is.na(condition),]	
	rm(condition, sNames, table1)

	library(DESeq2)
	ddsHTSeq <- DESeqDataSetFromHTSeqCount(sampleTable = sampleTable,
    	                                    directory   = "/",
	     	                                design      = ~ condition)
	ddsHTSeq  <- DESeq(ddsHTSeq)
	res       <- results(ddsHTSeq, cooksCutoff=FALSE)
	table.out <- data.frame(ids=rownames(res), as.data.frame(res))

	# add normalized sample counts to output and compute separate means for experiment and control group	
	counts.norm <- as.data.frame(counts(ddsHTSeq, normalized=T))
	table.out <- merge(table.out, counts.norm, by.x="ids", by.y="row.names", all.x=T)
	if (length(g2N) > 1) { table.out$baseMeanE <- rowMeans(table.out[,g2N], na.rm=T) } else { table.out$baseMeanE <-table.out[,g2N] }
	if (length(g1N) > 1) { table.out$baseMeanC <- rowMeans(table.out[,g1N], na.rm=T) } else { table.out$baseMeanC <-table.out[,g1N] }
	
	coln1 <- c('pvalue', 'padj', 'baseMean', 'baseMeanE', 'baseMeanC', 'log2FoldChange', 'lfcSE')
	coln2 <- c('p',      'q',    'meanExpr', 'meanExprE', 'meanExprC', 'fc',             'fcSE')
	coln2 <- paste(coln2, param3, sep='')
	colnames(table.out)[match(coln1,colnames(table.out))] <- coln2
""")

boxplotscript = StringInput(content="""\
                        	expr <- read.delim(var1, row.names=1)
							
							# read sample groups
							sample2group <- data.frame(sample=character(0), group=character(0))
							for(g in table1$ID) {
								members <- unlist(strsplit(table1[table1[,'ID']==g,'Members'],','))
								sample2group <- rbind(sample2group, data.frame(sample=members, group=g))
							}
													
							# translate ensembl gene ids to HGNC symbols
							names(table2)[names(table2)=="Ensembl Gene ID"] <- "Ensembl"
							names(table2)[names(table2)=="Associated Gene Name"] <- "HGNC"

							param2 <- get.parameter(cf,'param2','string')
							genesViaParameter <- !is.na(param2) && param2 != ""
							if (genesViaParameter) {  # gene list (HGNC symbols) provided via parameter?
								genes <- data.frame(HGNC=unlist(strsplit(param2, ',')))
								genes <- merge(genes, table2[,c("Ensembl", "HGNC")], all.x=T)
							} else {  # no: use genes (ensembl ids) provided via table input port
								genes <- merge(table3, table2[,c("Ensembl", "HGNC")], all.x=T)
                        		genes$HGNC[is.na(genes$HGNC) | genes$HGNC==""] <- genes$Ensembl
                        	}
							genes <- merge(genes, expr, by.x="Ensembl", by.y="row.names")
							                        	
							# melt dataframe into shape suitable for plotting and add sample groups
							library(reshape)
							gexpr <- melt(genes, id.vars=c("Ensembl", "HGNC"))
							names(gexpr)[names(gexpr)=="variable"] <- "sample"
                        	gexpr <- merge(gexpr, sample2group, all.X=T)
                        	
                        	# before plotting, preserve input gene order in lattice output (note: factor levels determines panel order)
                        	# original order might have been destroyed by merge
                        	if (genesViaParameter) {
								genes <- genes[match(unlist(strsplit(param2, ',')), genes$HGNC),] 
                        	} else {
								genes <- genes[match(table3$Ensembl, genes$Ensembl),] # original order was destroyed by merge, so let's restore it first
                        	}                        	
                        	gexpr$HGNC <- factor(as.character(gexpr$HGNC), levels=genes$HGNC)
                        	
                        	# get output file name
				  	    	out.dir   <- get.output(cf, 'document')
				  	    	plot.file <- sprintf('geneboxplot-%s-figure.pdf', get.metadata(cf, 'instanceName'))

							# plot
		    			    library(lattice)
		    			    pdf(file.path(out.dir, plot.file))
		    			    print(bwplot(value~group | HGNC, data=gexpr, 
		    			                 layout=c(4,(length(unique(gexpr$HGNC))+3) %/% 4), 
		    			                 notch=FALSE,
		    			                 as.table=TRUE,
		    			                 ylab="DESeq2 normalized expression",
		    			                 par.settings = list(box.umbrella=list(col="black"), box.rectangle = list(col="black")), 
		    			                 panel=function(x,y,...){
							   				panel.grid()
 							   				panel.bwplot(x,y,pch="|",do.out=FALSE, ...)
							   				panel.stripplot(x,y,jitter.data=TRUE,factor=0.8,pch=19,cex=0.3,...)
										}))
		    			    dev.off()

							# prepare latex output
		    			    document.out <- latex.figure(plot.file, caption=get.parameter(cf,'param1','string'))		    			    
							table.out <- data.frame('No output')							
			             """)
			             
gMoksisA = PiispanhiippaAnnotator(sourceKeys = deseqExprMatrix.expr @require,
                                  connection = moksiskaanInit.connection,
                                  inputDB    = XrefType_Ensembl_gene,
                                  organism   = Organism_Homo_sapiens,
                                  targetDB   = "BioentityName,DNARegion")

geneNames = CSVCleaner(original   = gMoksisA.bioAnnotation,
                       columns    = "sourceKey,BioentityName,DNARegion",
                       rename     = "sourceKey=Ensembl,BioentityName=Gene",
                       skipQuotes = "*",
                       trim       = true,
                       @keep      = true)



gstats  = record(genes=geneNames)
groups  = record()
degLst  = record()
eCSSRow = ""
for comparison : std.itercsv(comparisons) {
  gCase    = null
  gControl = null
  for g : std.split(comparison.Members, ',') {
     if (gCase    == null) { gCase    = g } else
     if (gControl == null) { gControl = g } else
     std.fail("Too many groups listed for ", comparison.ID, " (", comparison.Description, "). Members = ", comparison.Members, sep='')
  }
  setName = "stest_"+comparison.ID
  std.echo("***** Comparing", gCase, "expressions against", gControl, "expressions: "+setName)
  gLab = std.strReplace(comparison.ID, "^fc", "")
  groups[gLab] = {
    'id'       = gLab,
    'caseG'    = gCase,
    'controlG' = gControl,
    'stest'    = setName,
    'desc'     = comparison.Description
  }
  eCSSRow = "*\t"+comparison.ID+"\t0.00\ttrue\tNA\tNA\tNA\t#0000BB\t#ffffff\tNA\t<= -"+fcLimitInclude+"\n"+
            "*\t"+comparison.ID+"\t0.00\ttrue\tNA\tNA\tNA\t#00FF00\t#ffffff\tNA\t>= "+ fcLimitInclude+"\n"+
            "*\tp"+gLab+"\t0.00e00\tNA\tNA\tNA\tNA\tNA\tNA\tNA\tNA\n"+
            "*\tq"+gLab+"\t0.00e00\tNA\tNA\tNA\tNA\tNA\tNA\tNA\tNA\n"+
            "*\tp"+gLab+"\tNA\ttrue\tNA\tNA\tNA\t#ff0000\tNA\tNA\t<= "+pLimitInclude+"\n"+
            "*\tq"+gLab+"\tNA\ttrue\tNA\tNA\tNA\t#ff0000\tNA\tNA\t<= "+qLimitInclude+"\n"+
            eCSSRow

  if (gLab == "iAMPspecvsCD19") {
	  @out.table.filename = "stats.csv"
	  stest = TableQuery(table1 = stest_fciAMPvsCD19.table @require,
	                     table2 = degs_iAMPvsPC.table @ require,
	                     table3 = degs_iAMPvsER.table @ require,
	                     table4 = stest_fcERvsPC.table @ require,
	                       query  = """\
	                                SELECT A."ids",	
	                                       A."meanExpriAMPvsCD19" AS "meanExpriAMPspecvsCD19", 
	                                       A."fciAMPvsCD19"       AS "fciAMPspecvsCD19",
	                                       A."fcSEiAMPvsCD19"     AS "fcSEiAMPspecvsCD19", 
	                                       A."stat",
	                                       A."piAMPvsCD19"        AS "piAMPspecvsCD19",
	                                       A."qiAMPvsCD19"        AS "qiAMPspecvsCD19"
	                                FROM   table1 A 
	                                       INNER JOIN table2 B ON (A."ids" = B."ids")
	                                       INNER JOIN table3 C ON (A."ids" = C."ids")
	                                       LEFT OUTER JOIN table4 D ON (A."ids" = D."ids")
	                                WHERE  (D."fcERvsPC" IS NULL OR ABS(D."fcERvsPC") < """+fcLimitExclude+""" OR  
	                                       D."pERvsPC" IS NULL OR D."pERvsPC" > """+pLimitExclude+""" OR  
	                                       D."qERvsPC" IS NULL OR D."qERvsPC" > """+qLimitExclude+""" OR  
	                                       D."meanExprERvsPC" IS NULL OR D."meanExprERvsPC" < """+minExprExclude+""")
	                                ORDER  BY 1
	                                """,
	                       @name = setName)
	  gstats[gLab] = stest.table
  } else if (gLab == "PCspecvsCD19") {
	  @out.table.filename = "stats.csv"
	  stest = TableQuery(table1 = stest_fcPCvsCD19.table @require,
	                     table2 = degs_iAMPvsPC.table @ require,
	                     table3 = degs_ERvsPC.table @ require,
	                     table4 = stest_fciAMPvsER.table @ require,
	                       query  = """\
	                                SELECT A."ids",	
	                                       A."meanExprPCvsCD19" AS "meanExprPCspecvsCD19", 
	                                       A."fcPCvsCD19"       AS "fcPCspecvsCD19",
	                                       A."fcSEPCvsCD19"     AS "fcSEPCspecvsCD19", 
	                                       A."stat",
	                                       A."pPCvsCD19"        AS "pPCspecvsCD19",
	                                       A."qPCvsCD19"        AS "qPCspecvsCD19"
	                                FROM   table1 A 
	                                       INNER JOIN table2 B ON (A."ids" = B."ids")
	                                       INNER JOIN table3 C ON (A."ids" = C."ids")
	                                       LEFT OUTER JOIN table4 D ON (A."ids" = D."ids")
	                                WHERE  (D."fciAMPvsER" IS NULL OR ABS(D."fciAMPvsER") < """+fcLimitExclude+""" OR  
	                                       D."piAMPvsER" IS NULL OR D."piAMPvsER" > """+pLimitExclude+""" OR  
	                                       D."qiAMPvsER" IS NULL OR D."qiAMPvsER" > """+qLimitExclude+""" OR  
	                                       D."meanExpriAMPvsER" IS NULL OR D."meanExpriAMPvsER" < """+minExprExclude+""")
	                                ORDER  BY 1
	                                """,
	                       @name = setName)
	  gstats[gLab] = stest.table
  } else if (gLab == "ERspecvsCD19") {
	  @out.table.filename = "stats.csv"
	  stest = TableQuery(table1 = stest_fcERvsCD19.table @require,
	                     table2 = degs_iAMPvsER.table @ require,
	                     table3 = degs_ERvsPC.table @ require,
	                     table4 = stest_fciAMPvsPC.table @ require,
	                       query  = """\
	                                SELECT A."ids",	
	                                       A."meanExprERvsCD19" AS "meanExprERspecvsCD19", 
	                                       A."fcERvsCD19"       AS "fcERspecvsCD19",
	                                       A."fcSEERvsCD19"     AS "fcSEERspecvsCD19", 
	                                       A."stat",
	                                       A."pERvsCD19"        AS "pERspecvsCD19",
	                                       A."qERvsCD19"        AS "qERspecvsCD19"
	                                FROM   table1 A 
	                                       INNER JOIN table2 B ON (A."ids" = B."ids")
	                                       INNER JOIN table3 C ON (A."ids" = C."ids")
	                                       LEFT OUTER JOIN table4 D ON (A."ids" = D."ids")
	                                WHERE  (D."fciAMPvsPC" IS NULL OR ABS(D."fciAMPvsPC") < """+fcLimitExclude+""" OR  
	                                       D."piAMPvsPC" IS NULL OR D."piAMPvsPC" > """+pLimitExclude+""" OR  
	                                       D."qiAMPvsPC" IS NULL OR D."qiAMPvsPC" > """+qLimitExclude+""" OR  
	                                       D."meanExpriAMPvsPC" IS NULL OR D."meanExpriAMPvsPC" < """+minExprExclude+""")
	                                ORDER  BY 1
	                                """,
	                       @name = setName)
	  gstats[gLab] = stest.table
  } else if (gLab == "iAMPandPCspecvsCD19") {
	  @out.table.filename = "stats.csv"
	  stest = TableQuery(table1 = stest_fciAMPandPCvsCD19.table @require,
	                     table2 = degs_iAMPvsER.table @ require,
	                     table3 = degs_ERvsPC.table @ require,
	                     table4 = stest_fcERvsCD19.table @ require,
	                       query  = """\
	                                SELECT A."ids",	
	                                       A."meanExpriAMPandPCvsCD19" AS "meanExpriAMPandPCspecvsCD19", 
	                                       A."fciAMPandPCvsCD19"       AS "fciAMPandPCspecvsCD19",
	                                       A."fcSEiAMPandPCvsCD19"     AS "fcSEiAMPandPCspecvsCD19", 
	                                       A."stat",
	                                       A."piAMPandPCvsCD19"        AS "piAMPandPCspecvsCD19",
	                                       A."qiAMPandPCvsCD19"        AS "qiAMPandPCspecvsCD19"
	                                FROM   table1 A 
	                                       INNER JOIN table2 B ON (A."ids" = B."ids")
	                                       INNER JOIN table3 C ON (A."ids" = C."ids")
	                                       LEFT OUTER JOIN table4 D ON (A."ids" = D."ids")
	                                WHERE  (D."fcERvsCD19" IS NULL OR ABS(D."fcERvsCD19") < """+fcLimitExclude+""" OR  
	                                       D."pERvsCD19" IS NULL OR D."pERvsCD19" > """+pLimitExclude+""" OR  
	                                       D."qERvsCD19" IS NULL OR D."qERvsCD19" > """+qLimitExclude+""" OR  
	                                       D."meanExprERvsCD19" IS NULL OR D."meanExprERvsCD19" < """+minExprExclude+""")
	                                ORDER  BY 1
	                                """,
	                       @name = setName)
	  gstats[gLab] = stest.table
  } else {
	  @out.table.filename = "stats.csv"
	  stest = REvaluate(var1   = bamCounts   @require @doc="Gene specific read counts",
	                    table1 = sampleGroups     @require @doc="Sample sets",
	                    script = stestR,
	                    param1 = gControl,
	                    param2 = gCase,
	                    param3 = gLab,
	                    @name  = setName)
	  gstats[gLab] = stest.table
  }

  degCall = TableQuery(table1 = gstats[gLab] @require,
                       query  = """\
                                SELECT DISTINCT "ids"
                                FROM   table1
                                WHERE  (ABS("fc"""+gLab+'''")  >= '''+fcLimitInclude+""") AND
                                       ("p"""+gLab+'''"        <= '''+pLimitInclude +""") AND
                                       ("q"""+gLab+'''"        <= '''+qLimitInclude +""") AND
                                       (("meanExprE"""+gLab+'''" >= '''+minExprInclude+""") OR
                                       ("meanExprC"""+gLab+'''" >= '''+minExprInclude+"""))
                                ORDER  BY 1
                                """,
                       @name  = "degs_"+gLab)
  degLst[gLab] = degCall.table

  // make 'CD19+' match in following regular expression 
  gControlEscaped = std.strReplace(gControl,"\\+","\\\\+")
    
  samples = CSV2IDList(table1    = sampleGroups @require,
                       columnIn  = "Members",
                       columnOut = ".GeneId",
                       isList    = true,
                       regexp1   = "ID=("+gCase+"|"+gControlEscaped+")",
                       @name     = "samples_"+gLab)
  groups[gLab].samples = samples.ids
}

@out.document.filename = "document.tex"
pge = PGE(query=degs_iAMPvsER.table, reference=gtf, cmdPrefix="docker run --rm=true -w ${metadata_componentPath} --volumes-from anduril-moksiskaan cfrech/anduril-pge /root/init.sh")
 

degSets = CSV2SetList(tables=degLst)

degReportRefs = XrefLinkRule(moksiskaan = moksiskaanInit.connection,
                             columns    = "Ensembl=Ensembl",
                             xrefTypes  = XrefType_Ensembl_gene)

goGroupTableRefs = XrefLinkRule(moksiskaan = moksiskaanInit.connection,
                                columns    = "GO=GO,Ensembl=Gene",
                                xrefTypes  = XrefType_Gene_Ontology+","+XrefType_Ensembl_gene,
                                @enabled   = useFunct)

statsAllTable = CSVJoin(array = gstats @require, intersection = true)

statsAllCSS = StringInput(content=std.concat(sep="\n",
  "Row\tColumn\tFormat\tBold\tAlign\tFontSize\tUnderline\tTextColor\tBGColor\tBorder\tCondition",
  "1\t*\tNA\ttrue\tNA\t12\ttrue\t#000000\t#ffffff\tNA\tNA",
  "*\tEnsembl\tNA\tfalse\tleft\t6\tfalse\tNA\tNA\tNA\tNA",
  "*\tDNARegion\tNA\tNA\tleft\t6\tfalse\tNA\tNA\tNA\tNA",
  eCSSRow
))

statsAllExcel = CSV2Excel(csv           = statsAllTable,
                          refs          = degReportRefs,
                          style         = statsAllCSS,
                          frozenColumns = 2,
                          frozenRows    = 1,
                          sheetNames    = "statistics")

venn = VennDiagram(sets         = degSets,
                    cexSetName   = 0.3,
                    cexSetSize   = 0.3,
                    doWeights    = true,
                    sets1        = "iAMPvsPC,iAMPvsER,ERvsPC",
                    sets2        = "iAMPvsImmature,PCvsImmature,ERvsImmature",
                    sets3        = "iAMPvsPreB,PCvsPreB,ERvsPreB",
                    sets4        = "iAMPvsMature,PCvsMature,ERvsMature",
                    sectionTitle = "Gene set comparisons",
                    sectionType  = "subsection",
                    types        = "circles")

degReports = record(venn=venn.report)

// --------- //
//  HEATMAPS //
// --------- //

geneGOA = TableQuery(table1 = geneGO    @require,
                     table2 = geneNames @require,
                     query  = """\
                              SELECT O.*, A."Gene"
                              FROM   table1 O, table2 A
                              WHERE  (O."xref10" = A."Ensembl")
                              """)

degTables = record()
for ID, group : groups {
  std.echo("***** Preparing results for", ID, "comparison.")
  degs  = degLst[ID]
  stest = gstats[ID]

  degTable = TableQuery(table1 = degs      @require,
                        table2 = stest     @require,
                        table3 = geneNames @require,
                        table4 = geneAnnot @require,
                        query  = '''
                                 SELECT G."ids"                      AS "Ensembl",
                                        A."Gene"                     AS "Gene",
                                        S."fc'''+group.id+'''"       AS "fc",
                                        S."meanExprE'''+group.id+'''" AS "exprA",
                                        S."meanExprC'''+group.id+'''" AS "exprB",
                                        S."q'''+group.id+'''"        AS "qValue",
                                        CONCAT(D."Chromosome Name", D."Band") AS "Band",
                                        SUBSTR(D."Description", 1, 65) AS "Description",
                                        CASEWHEN(S."fc'''+group.id+'''" > 0, 1, -1) AS "status"
                                 FROM   table1 G, table2 S
                                        LEFT OUTER JOIN table3 AS A ON (G."ids" = A."Ensembl")
                                        LEFT OUTER JOIN table4 AS D ON (G."ids" = D."Ensembl Gene ID")
                                 WHERE  (G."ids" = S."ids")
                                 ORDER  BY "qValue", ABS("fc") DESC
                                 ''',
                        @name  = "degTable_"+ID)

  degTables[ID] = degTable

  if (ID == "iAMPspecvsCD19" || ID == "PCspecvsCD19" || ID == "ERspecvsCD19" || ID == "iAMPandPCspecvsCD19") {
  	captionUp = "List of genes significantly lower expressed exclusively in "+group.caseG+" samples."+
  	          ' Criteria for non-differential expression among other samples were $|\log_2$ fold-change (fc)$|<'+fcLimitExclude+
  	          "$, minimum expression below "+minExprExclude+", p-value above "+pLimitExclude+", or multiple-testing corrected p-value above "+qLimitExclude+
  	          ". Expression difference shown relative to CD19+ samples."
  	captionDn = "List of genes significantly higher expressed exclusively in "+group.caseG+" samples."+
  	          ' Criteria for non-differential expression among other samples were $|\log_2$ fold-change (fc)$|<'+fcLimitExclude+
  	          "$, minimum expression below "+minExprExclude+", p-value above "+pLimitExclude+", or multiple-testing corrected p-value above "+qLimitExclude+
  	          ". Expression difference shown relative to CD19+ samples."
  } else {
    captionUp = "List of genes significantly higher expressed in "+group.caseG+" samples compared to "+group.controlG+
            ' samples, where the $\log_2$ fold-change (fc)$ \geq '+fcLimitInclude+"$ and the minimum mean expression is above "+minExprInclude+
            " in at least one of the two groups. The highest p-value accepted is "+pLimitInclude+
            ". Multiple hypothesis corrected p-values with a limit of "+qLimitInclude+" are shown as qValues. Sorted by qValue."
    captionDn = "List of genes significantly lower expressed in "+group.caseG+" samples compared to "+group.controlG+
            ' samples, where the $\log_2$ fold-change (fc)$ \leq -'+fcLimitInclude+"$ and the minimum mean expression is above "+minExprInclude+
            " in at least one of the two groups. The highest p-value accepted is "+pLimitInclude+
            ". Multiple hypothesis corrected p-values with a limit of "+qLimitInclude+" are shown as qValues. Sorted by qValue."
  }

  degTableUp = CSVFilter(csv=degTable, lowBound="fc=0", @name = "degTableUp_"+ID)                        
  degReportUp = CSV2Latex(tabledata    = degTableUp,
                             refs         = degReportRefs,
                             attach       = false,
                             caption      = captionUp,
                             columns      = "Ensembl,Gene,fc,qValue,exprA,exprB,Band,Description",
                             colFormat    = "llrrrrcp{7.5cm}",
                             countRows    = true,
                             dropMissing  = false,
                             listCols     = "",
                             numberFormat = "fc=#0.0,qValue=#0.0E00,exprA=#0.0,exprB=#0.0",
                             pageBreak    = false,
                             section      = "Genes with higher expression in "+group.caseG+" than "+group.controlG+" samples",
                             sectionType  = "subsection",
                             @name  = "degReportUp_"+ID)

  geneBoxplotUp = REvaluate(var1   = deseqExprMatrix.expr    @require @doc="Expression matrix",
                        table1 = sampleGroupsSimple  @require @doc="Sample sets",
                        table2 = geneAnnot           @require @doc="Gene annotations",
                        table3 = TableQuery(table1 = degTableUp, query='SELECT "Ensembl" FROM table1 LIMIT 12'),
                        param1 = 'Top-12 genes with higher expression in '+group.caseG+" than "+group.controlG+" samples. Genes ordered by statistical significance (qValue) from top-left to bottom-right.",
                        script = boxplotscript,
                        @name = "geneBoxplotUp_"+ID)
  geneBoxplotUpReport = LatexCombiner(latex1=geneBoxplotUp.document, pagebreak=true, sectionTitle="Top-12 genes with higher expression", sectionType="subsection", @name="geneBoxplotUpReport_"+ID)

  degTableDn = CSVFilter(csv=degTable, highBound="fc=0", @name = "degTableDn_"+ID)                        
  degReportDn = CSV2Latex(tabledata    = degTableDn,
                             refs         = degReportRefs,
                             attach       = false,
                             caption      = captionDn,
                             columns      = "Ensembl,Gene,fc,qValue,exprA,exprB,Band,Description",
                             colFormat    = "llrrrrcp{7.5cm}",
                             countRows    = true,
                             dropMissing  = false,
                             listCols     = "",
                             numberFormat = "fc=#0.0,qValue=#0.0E00,exprA=#0.0,exprB=#0.0",
                             pageBreak    = false,
                             section      = "Genes with lower expression in "+group.caseG+" than "+group.controlG+" samples",
                             sectionType  = "subsection",
                             @name = "degReportDn_"+ID)

  geneBoxplotDn = REvaluate(var1   = deseqExprMatrix.expr    @require @doc="Expression matrix",
                        table1 = sampleGroupsSimple  @require @doc="Sample sets",
                        table2 = geneAnnot           @require @doc="Gene annotations",
                        table3 = TableQuery(table1 = degTableDn, query='SELECT "Ensembl" FROM table1 LIMIT 12'),
                        param1 = 'Top-12 genes with lower expression in '+group.caseG+" than "+group.controlG+" samples. Genes ordered by statistical significance (qValue) from top-left to bottom-right.",
                        script = boxplotscript,
                        @name = "geneBoxplotDn_"+ID)
  geneBoxplotDnReport = LatexCombiner(latex1=geneBoxplotDn.document, pagebreak=true, sectionTitle="Top-12 genes with lower expression", sectionType="subsection", @name="geneBoxplotDnReport_"+ID)

  degReports[ID] = LatexCombiner(latex1=degReportUp, latex2=geneBoxplotUpReport, latex3=degReportDn, latex4=geneBoxplotDnReport, sectionTitle="DEGs: "+group.desc, sectionType="section")
  
  groupExpr = CSVFilter(csv            = deseqExprMatrix.expr,
                        auxiliary      = degs @require,
                        includeColumns = group.samples,
                        includeColumns = "RowName",
                        colOrder       = true,
                        @name          = "exprMatrix_"+ID,
                        @keep          = true)
  groupExprG = IDConvert(csv              = groupExpr,
                         conversionTable  = geneNames,
                         conversionColumn = "Gene",
                         keyColumn        = "",
                         unique           = true,
                         @name            = "exprMatrixG_"+ID,
                         @keep            = true)
  heatmap = HeatMapReport(matr           = groupExprG,
                          caption        = "Heatmap of DEGs between "+group.caseG+" and "+group.controlG+".",
                          cexCol         = 1.0,
                          cexRow         = 0.1,
                          clusterMethod  = "average",
                          distanceMetric = "pcc",
                          drawColnames   = true,
                          drawLegends    = true,
                          drawRownames   = true,
                          marginCol      = 3,
                          marginRow      = 2,
                          plotHeight     = 13,
                          plotWidth      = 11,
                          scale          = "row",
                          sectionTitle   = "Sample clusters",
                          sectionType    = "subsection",
                          symKey         = true,
                          width          = 16,
                          @enabled       = useFunct,
                          @name          = "heatmap_"+ID)
  goHeatmapA = CSVFilter(csv            = geneGOA,
                         auxiliary      = groupExpr @require,
                         @enabled       = useFunct,
                         @name          = "heatmapGOA_"+ID,
                         @keep          = true)

  goTreeCuts = record(
     iAMPvsPC = 0.3,
     iAMPvsER = 0.3,
     ERvsPC = 0.3
  )

  if (std.exists(goTreeCuts, key=ID)) {
     cutLimit = goTreeCuts[ID]
  } else {
     cutLimit = 0.3
  }
  goHeatmap = GOClustering(goAnnotations    = goHeatmapA,
                           expr             = groupExpr       @require,
                           similarityTable  = similarityTable @require,
                           asBitmap         = true,
                           cutLimit         = cutLimit,
                           dropUnknown      = true,
                           geneColumn       = "Gene",
                           grayScale        = false,
                           heatmapScale     = "row",
                           organism         = Organism_Homo_sapiens,
                           pvalues          = false,
                           showClusterNames = true,
                           title            = "GO clustering",
                           @name            = "heatmapGO_"+ID)
  degReports[ID+"hm"  ] = heatmap.report
  degReports[ID+"gohm"] = goHeatmap.report
}

// add report about expression of selected genes
boxplotSelectedGenes = REvaluate(var1   = deseqExprMatrix.expr    @require @doc="Expression matrix",
                        table1 = sampleGroupsSimple  @require @doc="Sample sets",
                        table2 = geneAnnot           @require @doc="Gene annotations",
                        param1 = 'Expression of manually selected genes. MME=CD10; MS4A1=CD20',
                        param2 = "ETV6,RUNX1,CRLF2,P2RY8,EBF1,PAX5,VPREB1,HMGN1,MME,CD34,CD19,MS4A1",
                        script = boxplotscript)
degReports["selectedGenes"] = LatexCombiner(latex1=boxplotSelectedGenes.document, pagebreak=true, sectionTitle="Expression of selected genes", sectionType="section")
degReports["pges"] = LatexCombiner(latex1=pge.document, pagebreak=true, sectionTitle="Positional enrichment of differentially expressed genes", sectionType="section")

degViews = LatexCombiner(array        = degReports,
                         pagebreak    = true,
                         tail         = '\newpage{}',
                         sectionTitle = "Differentially expressed genes")

degTablesExcel = CSV2Excel(array         = degTables,
                           refs          = degReportRefs,
                           frozenColumns = 2,
                           frozenRows    = 1,
                           missingValue  = '')

// -------------------- //
//  FUNCTIONAL ANALYSIS //
// -------------------- //

/**
 Prepares a document describing the biological properties of the given set
 of differentially expressed genes and the relationships between them.
 */
function FunctionalAnalysis(IDList        genes,
                            ActivityTable status,
                            string        title,
                            record        latexList) ->
                           (/* All outputs are appended to latexList */) {
    md = std.metadata()
    candiRep = CandidateReport(candidates        = genes,
                               status            = status,
                               moksiskaan        = moksiskaanInit.connection,
                               ensembl           = ensembl,
                               enrichmentTable   = enrichmentTable,
                               organism          = Organism_Homo_sapiens,
                               name              = title,
                               linkTypes         = std.concat(sep=",",
                                                     //LinkType_pathway_precedence,
                                                     //LinkType_protein_protein_interaction,
                                                     LinkType_chemical_reaction,
                                                     LinkType_protein_activation,
                                                     LinkType_protein_inhibition,
                                                     LinkType_protein_state_change,
                                                     LinkType_protein_binding,
                                                     LinkType_protein_dissociation,
                                                     LinkType_gene_expression,
                                                     LinkType_gene_repression,
                                                     LinkType_phosphorylation,
                                                     LinkType_dephosphorylation,
                                                     LinkType_glycosylation,
                                                     LinkType_ubiquitination,
                                                     LinkType_deubiquitination,
                                                     LinkType_methylation,
                                                     LinkType_demethylation,
                                                     LinkType_acetylation,
                                                     LinkType_deacetylation,
                                                     LinkType_sumoylation,
                                                     LinkType_desumoylation
                                                   ),
                               annotRules        = "",
                               bioentityTypes    = BioentityType_gene,
                               maxGap            = 1,
                               cytoscape         = false,
                               useStudies        = "",
                               hideGaps          = false,
                               isolateGroupNames = false,
                               expand            = "connected",
                               statusFilter      = "NA",
                               goLimInput        = 0.01,
                               goLimModel        = -0.01,
                               showCandidates    = true)
    latexList[md.instanceName+"_candidates"] = candiRep.report
    functRep = CandidateReport(candidates        = genes,
                               status            = status,
                               moksiskaan        = moksiskaanInit.connection,
                               ensembl           = ensembl,
                               enrichmentTable   = enrichmentTable,
                               organism          = Organism_Homo_sapiens,
                               name              = title+" (biological function)",
                               linkTypes         = std.concat(sep=",",
                                                     LinkType_positive_regulation,
                                                     LinkType_negative_regulation
                                                   ),
                               annotRules        = "",
                               bioentityTypes    = std.concat(sep=",",
                                                     BioentityType_gene,
                                                     BioentityType_molecular_function,
                                                     BioentityType_biological_process
                                                   ),
                               maxGap            = 1,
                               cytoscape         = false,
                               useStudies        = "",
                               isolateGroupNames = true,
                               expand            = "down",
                               statusFilter      = "",
                               goLimInput        = -0.01,
                               goLimModel        = -0.01,
                               showCandidates    = false)

    secTitle = "Selected GO gategories"
    for name, group : goGroups {

       goGroupGenes = GOSearch(bioAnnotation = geneGO,
                           go            = go,
                           goColumn      = "GO",
                           numMatches    = 1,
                           parentFilter  = true,
                           terms         = group.terms,
                           @enabled      = useFunct,
                           @name         = "goGenes_"+name)
       group['genes'] = goGroupGenes.hits

       goGroupSelect = TableQuery(table1 = candiRep.bioAnnotation @require,
                                  table2 = group.genes            @require,
                                  table3 = status                 @require,
                                  query  = """\
                                           SELECT G."entry"     AS "Ensembl",
                                                  A.".GeneName" AS "Gene",
                                                  A.".GeneDesc" AS "Description",
                                                  GROUP_CONCAT(DISTINCT G."GO"   ORDER BY G."GO" SEPARATOR ',' ) AS "GO",
                                                  GROUP_CONCAT(DISTINCT G."desc" ORDER BY G."GO" SEPARATOR '; ') AS "name",
                                                  S."status"
                                           FROM   table1 A, table2 G, table3 S
                                           WHERE  (G."entry" = A.".GeneId") AND
                                                  (G."entry" = S."Ensembl")
                                           GROUP  BY G."entry", A.".GeneName", A.".GeneDesc", S."status"
                                           ORDER  BY "Gene"
                                           """,
                                  @name  = "goGroupSelect_"+name)
       goGroupTable = CSV2Latex(tabledata    = goGroupSelect,
                                refs         = goGroupTableRefs,
                                caption      = "Genes associated with "+group.title+" related Gene Ontology terms ("+
                                               std.strReplace(group.terms,',',', ')+").",
                                columns      = "status,Gene,Description,GO,name",
                                colFormat    = "llp{8cm}p{1cm}p{6cm}",
                                countRows    = true,
                                dropMissing  = false,
                                listCols     = "GO",
                                section      = secTitle,
                                @name        = "goGroupTable_"+name)
       secTitle = ""
       latexList[md.instanceName+"_"+name] = goGroupTable.report
    }
    latexList[md.instanceName+"_function"] = functRep.report
    return record()
}


// Interesting GO topics for additional tables in the report of functional analysis
goGroups = record(
  apoptosis = record(
    title = "apoptosis",
    terms = std.concat(sep=",",
               "GO:0006915"  // apoptotic process
            )
  ),
  cellcycle = record(
    title = "cell cycle",
    terms = std.concat(sep=",",
               "GO:0007049"  // cell cycle
            )
  ),
  complement = record(
    title = "complement system",
    terms = std.concat(sep=",",
               "GO:0001848", // complement binding
               "GO:0002430", // complement receptor mediated signaling pathway
               "GO:0006956", // complement activation
               "GO:0097278"  // complement-dependent cytotoxicity
            )
  ),
  hypoxia = record(
    title = "hypoxia",
    terms = std.concat(sep=",",
               "GO:0036293"  // response to decreased oxygen levels
            )
  ),
  inflammation = record(
    title = "inflammation",
    terms = std.concat(sep=",",
               "GO:0006954"  // inflammatory response
            )
  ),
  stimulation = record(
    title = "stimulation",
    terms = std.concat(sep=",",
               "GO:0031295"  // T cell costimulation
            )
  )
)

if (useFunct) {
	funcReps  = record()
	for ID, group : groups {
  		std.echo("***** Functional analysis for", ID, "comparison.")

		degTable = degTables[ID]
		stest = gstats[ID]
 		statusTable = TableQuery(table1   = degTable @require,
                           table2   = stest    @require,
                           query    = '''
                                      SELECT "Ensembl", "status" FROM table1
                                      UNION
                                      SELECT "ids" AS "Ensembl", -2 AS "status"
                                      FROM   table2
                                      WHERE  ("meanExpr'''+group.id+'''" < 0.02)
                                      ''',
                           @enabled = useFunct,
                           @name    = "statusTable_"+ID)

		degs  = degLst[ID]
     	geneFunction = FunctionalAnalysis(force genes  = degs,
                                       force status = statusTable,
                                       title        = group.caseG+" versus "+group.controlG,
                                       latexList    = funcReps,
                                       @name        = "geneFunction_"+ID)
  	}

	functioLatex = LatexCombiner(array = funcReps)
	functioReport = LatexPDF(document = functioLatex,
                         header   = docTemplate.header,
                         footer   = docTemplate.footer,
                         useRefs  = true,
                         verbose  = false)
}

// --------------------------------
// Experimental setup
// --------------------------------
expSetup1   = ExperimentSetup(force groups = sampleGroups,
                              definWidth   = 10.0,
                              descWidth    = 6.0,
                              sectionType  = "subsection",
                              sectionTitle = "Sample groups")
expSetup2   = ExperimentSetup(force groups = comparisons,
                              definWidth   = 7.0,
                              descWidth    = 9.0,
                              sectionType  = "subsection",
                              sectionTitle = "Comparisons between sample groups")
expSetupGV1 = GraphVisualizer(expSetup1.graph,
                              reportHeight = 26,
                              reportWidth  = 18,
                              layout       = "spring2",
                              latexTail    = '\newpage{}')
expSetupGV2 = GraphVisualizer(expSetup2.graph,
                              reportHeight = 26,
                              reportWidth  = 18,
                              layout       = "spring2",
                              latexTail    = '\newpage{}')

expReport = LatexCombiner(expSetup1.report,
  						  expSetup2.report,
  						  expSetupGV1.figure,
  						  expSetupGV2.figure,
                          sectionTitle = "Experimental setup",
                          sectionType  = "section",
                          pagebreak    = true)


// --------------------------------
// final report
// --------------------------------

propertiesDoc = Properties2Latex(moksiskaanInit.connection,
                                 ensembl,
                                 section     = "System configurations",
                                 sectionType = "section",
                                 hide        = "database.password")


combinedLatex = LatexCombiner(array={
  expReport,
  qcReport,
  degViews,
  propertiesDoc,
  rConfig.report},
  @keep = false
)

combinedPDF = LatexPDF(document = combinedLatex,
                    header   = docTemplate.header,
                    footer   = docTemplate.footer,
                    useRefs  = true,
                    verbose  = false)

OUTPUT(combinedPDF.document)
